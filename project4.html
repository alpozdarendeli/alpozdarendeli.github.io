<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
        });
    </script>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            max-width: 1200px;
            margin: 0 auto;
            background-color: #f4f4f4;
            color: #333;
        }
        h1, h2 {
            color: #2c3e50;
        }
        h1 {
            border-bottom: 2px solid #2c3e50;
            padding-bottom: 10px;
        }
        .project-overview {
            background-color: #fff;
            padding: 20px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        .image-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-bottom: 20px;
        }
        .image {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 20px;
        }
        .image img {
            max-width: none;
            width: 1350%;
            height: auto;
        }
        .image-gri {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin-bottom: 20px;
        }
        .image-gr {
            display: grid;
            grid-template-columns: repeat(1, 1fr);
            gap: 15px;
            margin-bottom: 20px;
            justify-items: center; 
            align-items: center; 
        }
        .image-g {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 15px;
            margin-bottom: 20px;
        }
        .image-container {
            background-color: #fff;
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .image-container img {
            max-width: 100%;
            height: auto;
            border-radius: 3px;
        }
        .image-subtitle {
            margin-top: 8px;
            font-style: italic;
            font-size: 0.9em;
            color: #555;
        }
        .clear-float {
            clear: both;
            width: 100%;
        }
        .image-description {
            margin-top: 8px;
            font-style: italic;
            font-size: 0.9em;
            color: #555;
        }
                
        .equation {
            margin: 20px 0;
            overflow-x: auto;
        }
    </style>
</head>
<body>
    <h1>Project 4: Image Warping and Mosaicing</h1>
    <h2>Alp Eren Ozdarendeli</h2>

    <div class="Background">
        <h2>Part A</h2>
    </div>
    
    <div class="project-overview">
        <h2>Shoot the Pictures</h2>
            <p> To morph two images, we need to select points of correspondences. I used the given tool to select points on the images. After defining the correspondences, I used Delaney Triangulation to triangulate the mean points of Larry David's and Can Ruso's images to find the mean shape. </p>
            <div class="image-grid">
            <div class="image-container">
                <img src="proj3images/ruso_tr.png" alt="d_x.jpg">
                <p class="image-subtitle">Ruso points</p>
            </div>
            <div class="image-container">
                <img src="proj3images/david_tr.png" alt="d_y.jpg">
                <p class="image-subtitle">David points</p>
            </div>
            <div class="image-container">
                <img src="proj3images/mid_tr.png" alt="magnitude.jpg">
                <p class="image-subtitle">Mean points on Can Ruso</p>
            </div>
        </div>
        <div class="clear-float"></div>
        <h2>Recover Homographies</h2>
    <p>To recover homographies, we want to find the projective transformation that transforms coordinates of a point with an augmented coordinate (x, y, 1) to another augmented coordinates with the same center of projection (x', y', w). When scaling factor is 0, we have the following equation:</p>
    <div class="equation">
        \[
        \begin{bmatrix}
        a & b & c \\
        d & e & f \\
        g & h & 1
        \end{bmatrix}
        \begin{bmatrix}
        x \\
        y \\
        1
        \end{bmatrix}  =
        \begin{bmatrix}
        wx' \\
        wy' \\
        w
        \end{bmatrix} 
        \]
    </div>
    <p>If we expand out the equations and divide wx' and wy' by w:</p>
    <div class="equation">
                \[
        x' = \frac{ax + by + c}{gx + hy + 1} \\
        y' = \frac{dx + ey + f}{gx + hy + 1}
        \]
    </div>
    <p>We can write the same equations for different corresponding points, if we stack them together:</p>
    <div class="equation">
        \[
        \begin{bmatrix}
        x_1 & y_1 & 1 & 0 & 0 & 0 & -x_1 x'_1 & -y_1 x'_1 \\
        0 & 0 & 0 & x_1 & y_1 & 1 & -x_1 y'_1 & -y_1 y'_1 \\
        x_2 & y_2 & 1 & 0 & 0 & 0 & -x_2 x'_2 & -y_2 x'_2 \\
        0 & 0 & 0 & x_2 & y_2 & 1 & -x_2 y'_2 & -y_2 y'_2
        \end{bmatrix}
        \begin{bmatrix}
        a \\
        b \\
        c \\
        d \\
        e \\
        f \\
        g \\
        h
        \end{bmatrix} =
        \begin{bmatrix}
        x'_1 \\
        y'_1 \\
        x'_2 \\
        y'_2
        \end{bmatrix}
        \]
          </div>
    <p> However, ideally, we should use more than 4 correspondence points to make homography recovery stable and less prone to error. Using more than 4 correspondence points would make the equation overdetermined and we solve this by least-squares solver to recover the homographies.</p>
</html>
        <div class="image-grid">
        <div class="image-container">
            <img src="proj3images/warpedcan.png" alt="ataturk.jpg">
            <p class="image-subtitle">Warped Can</p>
        </div>
        <div class="image-container">
            <img src="proj3images/warpedlarry.png" alt="ataturk_sharp.jpg">
            <p class="image-subtitle">Warped Larry</p>
        </div>
        <div class="image-container">
            <img src="proj3images/averageshape.png" alt="ataturk_sharp.jpg">
            <p class="image-subtitle">Mid-way Face</p>
        </div>
        </div>
        <div class="clear-float"></div>
        <h2>Warp the Images</h2>
            <p> To produce the morphing sequence, I applied the previous procedure for finding the mid-way face with different warp and dissolve fractions. To create 45 frames, I increase the fractions by 1/45 for each frame. Dissolve fraction determines the weight of source image for the final image while taking the average of the source images. Warp fraction determines how close the shape of final image will be to the source image. Here is a gif with 45 frames for transforming Larry David to Can:</p>
        <div class="clear-float"></div>
        <div class="image-gr">
        <div class="image-container">
            <img src="proj3images/larrycan.gif" alt="taj.jpg">
            <p class="image-subtitle">Larry David to Can Ruso</p>
        </div>
        </div>
        <div class="clear-float"></div>
        <p> I also applied the morphing sequence to my father and myself. It turns out we look pretty alike:</p>
        <div class="image-gr">
        <div class="image-container">
            <img src="proj3images/morph.gif" alt="taj.jpg">
            <p class="image-subtitle">My father to Me</p>
        </div>
        </div>
        <h2>Image Rectification</h2>
            <p> For image rectification I used the warping function I defined earlier with a little nuance. Instead of selecting corresponding points between two images, I chose the edges of a rectangle or a square shape from an image and I manually defined the corresponding points so that these edges would form a rectified rectangular shape. Here are the corresponding points I have chosen and the resultant rectified image:</p>
        <div class="clear-float"></div>
        <div class="image-gri">
        <div class="image-container">
            <img src="proj4images/tip.png" alt="taj.jpg">
        </div>
        <div class="image-container">
            <img src="proj4images/tikare.png" alt="taj.jpg">
        </div>
        <div class="image-container">
            <img src="proj4images/yastikp.png" alt="taj.jpg">
        </div>
        <div class="image-container">
            <img src="proj4images/yastikkare.png" alt="taj.jpg">
        </div>
        </div>
        <div class="clear-float"></div>
        <p> Here is the mean face of the population:</p>
        <div class="image-gr">
        <div class="image-container">
            <img src="proj3images/avgface.jpg" alt="taj.jpg">
        </div>
        </div>
        <div class="clear-float"></div>
        <p> After computing the mean face of the population, I warped Can's face into the average face, and warped the mean face into Can's face:</p>
        <div class="image-gri">
        <div class="image-container">
            <img src="proj3images/warped_avg.png" alt="taj.jpg">
        </div>
        <div class="image-container">
            <img src="proj3images/warpedcan_avg.png" alt="taj.jpg">
        </div>
        </div>
        <div class="clear-float"></div>
        <h2>Blend the images into a mosaic</h2>
            <p> To blend the images into a mosaic, firstly, I warped one of the images based on the correspondence points. Before warping, I calculate the final image's shape and align the warped image with the original image by calculating if there is any offsets. Then, I created indicator masks for both the original and warped image in the final image's shape. These masks set pixels to 1 if there is a corresponding pixel in the original or warped image. I found the overlapping pixels between the two images using these masks. After finding the overlapping pixels, I used a Laplacian stack for blending. For a Laplacian stack, we need a mask for the images to blend. I separated the mask into two parts. The first part is the non-overlapping pixels for the original image. Since there is no overlap between the images at these pixels, I used the indicator mask I created for the images at these pixels. For the overlapping pixels, the computation is more complicated. I used cv2.distanceTransform to calculate distance to non-overlapping pixels from both images for each overlapping pixel. Then, I found the ratio of distance2/(distance2+distance1) for each overlapping pixel where distance1 indicates the distance to the closest non-overlapping pixel in the original image. By combining these two parts, I create the mask for the Laplacian stack: </p>
        <div class="image-grid">
        <div class="image-container">
            <img src="proj4images/mask_1_non_overlap.png" alt="taj.jpg">
            <p class="image-subtitle"> Non-overlap part of the mask</p>
        </div>
        <div class="image-container">
            <img src="proj4images/mask_1_overlap.png" alt="taj_sharp.jpg">
            <p class="image-subtitle">Overlap part of the mask</p>
        </div>
        <div class="image-container">
            <img src="proj4images/mask_1_full.png" alt="taj_sharp.jpg">
            <p class="image-subtitle">Full mask</p>
        </div>
        </div>
        <p> After creating the mask, I used a Laplacian stack with original and warped images padded to the final image's shape to create the mosaic:
        <div class="image-gri">
        <div class="image-container">
            <img src="proj4images/IMG_5854.png" alt="taj.jpg">
        </div>
        <div class="image-container">
            <img src="proj4images/IMG_5855.png" alt="taj_sharp.jpg">
        </div>
        </div>
        <div class="clear-float"></div>
        <div class="image">
        <div class="image-container">
        <img src="proj4images/mosaic1.png" alt="taj.jpg">
        </div>
        </div>
    </div>
</body>
</html>
    </div>
</body>
</html>
